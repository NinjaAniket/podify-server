import { RequestHandler } from "express";
import { PipelineStage, Types, isValidObjectId } from "mongoose";
import User from "#/models/user";
import { paginationQuery } from "#/@types/misc";
import Audio from "#/models/audio";
import Playlist from "#/models/playlist";
import History from "#/models/history";
import moment from "moment";
import { getUserPreviousHistory } from "#/utils/helper";
import AutoGeneratedPlaylist from "#/models/autoGeneratedPlaylist";

export const updateFollower: RequestHandler = async (req, res) => {
	const { profileId } = req.params;
	let status: "added" | "removed";

	if (!isValidObjectId(profileId))
		return res.status(422).json({ error: "Invalid Profile Id" });

	const profile = await User.findById(profileId);

	if (!profile) return res.status(404).json({ error: "Profile not found!" });

	const alreadyFollower = await User.findOne({
		_id: profileId,
		followers: req.user?.id,
	});

	console.log(alreadyFollower, "al");

	if (alreadyFollower) {
		await User.updateOne(
			{
				_id: profileId,
			},
			{
				$pull: {
					followers: req.user?.id,
				},
			}
		);
		status = "removed";
	} else {
		//follow user

		await User.updateOne(
			{
				_id: profileId,
			},
			{
				$addToSet: {
					followers: req.user?.id,
				},
			}
		);
		status = "added";
	}

	if (status === "added") {
		//update the following list (add)
		await User.updateOne(
			{ _id: req.user?.id },
			{
				$addToSet: {
					followings: profileId,
				},
			}
		);
	}

	if (status === "removed") {
		await User.updateOne(
			{ _id: req.user?.id },
			{
				$pull: {
					followings: profileId,
				},
			}
		);
	}
	res.json({ status });
};

export const getUploads: RequestHandler = async (req, res) => {
	const { limit = "20", pageNo = "0" } = req.query as paginationQuery;
	const data = await Audio.find({ owner: req.user?.id })
		.skip(parseInt(limit) * parseInt(pageNo))
		.limit(parseInt(limit))
		.sort("-createdAt");

	const audios = data.map((item) => {
		return {
			id: item._id,
			title: item.title,
			about: item.about,
			file: item.file.url,
			poster: item.poster?.url,
			date: item.createdAt,
			owner: { name: req.user?.name, id: req.user?.id },
		};
	});
	res.json({ audios });
};

export const getPublicUploads: RequestHandler = async (req, res) => {
	const { limit = "20", pageNo = "0" } = req.query as paginationQuery;
	const { profileId } = req.params;

	if (!isValidObjectId(profileId))
		return res.status(422).json({ error: "Invalid Profile Id" });

	const data = await Audio.find({ owner: profileId })
		.skip(parseInt(limit) * parseInt(pageNo))
		.limit(parseInt(limit))
		.sort("-createdAt")
		.populate("owner");

	const audios = data.map((item: any) => {
		return {
			id: item._id,
			title: item.title,
			about: item.about,
			file: item.file.url,
			poster: item.poster?.url,
			date: item.createdAt,
			owner: { name: item.owner.name, id: item.owner.id },
		};
	});
	res.json({ audios });
};

export const getPublicProfile: RequestHandler = async (req, res) => {
	const { profileId } = req.params;

	if (!isValidObjectId(profileId))
		return res.status(422).json({ error: "Invalid Profile Id" });

	const user = await User.findById(profileId);
	if (!user) return res.status(422).json({ error: "User not found" });

	res.json({
		profile: {
			id: user._id,
			name: user.name,
			followers: user.followers.length,
			avatar: user.avatar?.url,
		},
	});
};

export const getPublicPlaylist: RequestHandler = async (req, res) => {
	const { profileId } = req.params;

	const { limit = "20", pageNo = "0" } = req.query as paginationQuery;

	if (!isValidObjectId(profileId))
		return res.status(422).json({ error: "Invalid Profile Id" });

	const playlist = await Playlist.find({
		owner: profileId,
		visibility: "public",
	})
		.skip(parseInt(limit) * parseInt(pageNo))
		.limit(parseInt(limit))
		.sort("-createdAt");

	if (!playlist) return res.json({ playlist: [] });

	res.json({
		playlist: playlist.map((item) => {
			return {
				id: item._id,
				title: item.title,
				itemsCount: item.items.length,
				visibility: item.visibility,
			};
		}),
	});
};

export const getRecommendedByProfile: RequestHandler = async (req, res) => {
	const user = req.user;

	let matchOptions: PipelineStage.Match = {
		$match: { _id: { $exists: true } },
	};

	if (user) {
		//fetch users previous history

		const category = await getUserPreviousHistory(req);

		if (category?.length)
			matchOptions = {
				$match: { category: { $in: category } },
			};
	}

	const audios = await Audio.aggregate([
		{ $match: { _id: { $exists: true } } },
		{
			$sort: {
				"likes.count": -1,
			},
		},
		{ $limit: 10 },
		{
			$lookup: {
				from: "users",
				localField: "owner",
				foreignField: "_id",
				as: "owner",
			},
		},
		{ $unwind: "$owner" },
		{
			$project: {
				_id: 0,
				id: "$_id",
				title: "$title",
				category: "$category",
				about: "$about",
				file: "$file.url",
				poster: "$poster.url",
				owner: { name: "$owner.name", id: "$owner._id" },
			},
		},
	]);

	res.json({ audios });
};

export const getAutoGeneratedPlaylist: RequestHandler = async (req, res) => {
	//find out 5 playlist
	//1 mix 20

	const [result] = await History.aggregate([
		{
			$match: { owner: req.user!.id },
		},
		{
			$unwind: "$all",
		},
		{
			$group: {
				_id: "$all.audio",
				items: {
					$addToSet: "$all.audio",
				},
			},
		},
		{ $sample: { size: 20 } },
		{
			$group: { _id: null, items: { $push: "$_id" } },
		},
	]);

	const title = "Mix 20";

	if (result) {
		await Playlist.updateOne(
			{ owner: req.user!.id, title },
			{
				$set: { title, items: result.items, visibility: "auto" },
			},
			{
				upsert: true,
			}
		);
	}
	// 4 autogenerated playlist

	const category = await getUserPreviousHistory(req);
	let matchOptions: PipelineStage.Match = {
		$match: { _id: { $exists: true } },
	};

	if (category?.length) {
		matchOptions = { $match: { $title: { $in: category } } };
	}

	const autoGenerated = await AutoGeneratedPlaylist.aggregate([
		matchOptions,
		{
			$sample: { size: 4 },
		},
		{
			$project: {
				_id: 0,
				id: "$_id",
				title: "$title",
				itemsCount: { $size: "$items" },
			},
		},
	]);

	const playlist = await Playlist.findOne({ owner: req.user?.id, title });
	const finalList = autoGenerated.concat({
		id: playlist?._id,
		title: playlist?.title,
		itemsCount: playlist?.items.length,
	});

	res.json({
		playlist: finalList,
	});
};

export const getFollowersProfile = async (req: any, res: any) => {
	const { limit = "20", pageNo = "0" } = req.query as paginationQuery;
	const [result] = await User.aggregate([
		{ $match: { _id: req.user.id } },
		{
			$project: {
				followers: {
					$slice: [
						"$followers",
						parseInt(pageNo) * parseInt(limit),
						parseInt(limit),
					],
				},
			},
		},
		{
			$unwind: "$followers",
		},
		{
			$lookup: {
				from: "users",
				localField: "followers",
				foreignField: "_id",
				as: "userInfo",
			},
		},
		{ $unwind: "$userInfo" },
		{
			$group: {
				_id: null,
				followers: {
					$push: {
						id: "$userInfo._id",
						name: "$userInfo.name",
						avatar: "$userInfo.avatar.url",
					},
				},
			},
		},
	]);

	if (!result) {
		return res.json({ followers: [] });
	}
	res.json({
		followers: result.followers,
	});
};

export const getFollowingsProfile = async (req: any, res: any) => {
	const { limit = "20", pageNo = "0" } = req.query as paginationQuery;
	const [result] = await User.aggregate([
		{ $match: { _id: req.user.id } },
		{
			$project: {
				followings: {
					$slice: [
						"$followings",
						parseInt(pageNo) * parseInt(limit),
						parseInt(limit),
					],
				},
			},
		},
		{
			$unwind: "$followings",
		},
		{
			$lookup: {
				from: "users",
				localField: "followings",
				foreignField: "_id",
				as: "userInfo",
			},
		},
		{ $unwind: "$userInfo" },
		{
			$group: {
				_id: null,
				followings: {
					$push: {
						id: "$userInfo._id",
						name: "$userInfo.name",
						avatar: "$userInfo.avatar.url",
					},
				},
			},
		},
	]);

	if (!result) {
		return res.json({ followings: [] });
	}
	res.json({
		followings: result.followings,
	});
};

export const getFollowingsProfilePublic = async (req: any, res: any) => {
	const { limit = "20", pageNo = "0" } = req.query as paginationQuery;

	const { profileId } = req.params;

	if (!isValidObjectId(profileId))
		return res.status(422).json({ error: "Invalid Profile Id" });

	const [result] = await User.aggregate([
		{ $match: { _id: new Types.ObjectId(profileId) } },
		{
			$project: {
				followers: {
					$slice: [
						"$followers",
						parseInt(pageNo) * parseInt(limit),
						parseInt(limit),
					],
				},
			},
		},
		{
			$unwind: "$followers",
		},
		{
			$lookup: {
				from: "users",
				localField: "followers",
				foreignField: "_id",
				as: "userInfo",
			},
		},
		{ $unwind: "$userInfo" },
		{
			$group: {
				_id: null,
				followers: {
					$push: {
						id: "$userInfo._id",
						name: "$userInfo.name",
						avatar: "$userInfo.avatar.url",
					},
				},
			},
		},
	]);

	if (!result) {
		return res.json({ followers: [] });
	}
	res.json({
		followers: result.followers,
	});
};

export const getPlaylistAudios = async (req: any, res: any) => {
	const { limit = "20", pageNo = "0" } = req.query as paginationQuery;
	const { playlistId } = req.params;

	if (!isValidObjectId(playlistId))
		return res.status(422).json({ error: "Invalid playlist id" });

	const aggregateLogic = [
		{
			$match: {
				_id: new Types.ObjectId(playlistId),
				visibility: { $ne: "private" },
			},
		},
		{
			$project: {
				items: {
					$slice: [
						"$items",
						parseInt(pageNo) * parseInt(limit),
						parseInt(limit),
					],
				},
				title: "$title",
			},
		},
		{
			$unwind: "$items",
		},
		{
			$lookup: {
				from: "audios",
				localField: "items",
				foreignField: "_id",
				as: "audios",
			},
		},
		{
			$unwind: "$audios",
		},
		{
			$lookup: {
				from: "users",
				localField: "audios.owner",
				foreignField: "_id",
				as: "userInfo",
			},
		},
		{ $unwind: "$userInfo" },
		{
			$group: {
				_id: {
					id: "$_id",
					title: "$title",
				},
				audios: {
					$push: {
						id: "$audios._id",
						title: "$audios.title",
						about: "$audios.about",
						file: "$audios.file.url",
						poster: "$audios.poster.url",
						category: "$audios.category",
						owner: {
							name: "$userInfo.name",
							id: "$userInfo._id",
						},
					},
				},
			},
		},
		{
			$project: {
				_id: 0,
				id: "$_id.id",
				title: "$_id.title",
				audios: "$$ROOT.audios",
			},
		},
	];
	const [playlistResult] = await Playlist.aggregate(aggregateLogic);

	if (!playlistResult) {
		const [autoPlaylistResult] = await AutoGeneratedPlaylist.aggregate(
			aggregateLogic
		);
		return res.json({ list: autoPlaylistResult });
	}

	res.json({ list: playlistResult });
};
